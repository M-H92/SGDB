<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="module" src="../../../scripts/syntaxHighlighting.js"></script>
    <script type="module" src="../../../scripts/navbar/addNavbar.js"></script>
    <link rel="stylesheet" href="../../../../ressources/style.css" />
</head>

<body>
    <main>
        <h1>Procédures stockées</h1>
        <ol>
            <li>Introduction</li>
            <li>Nomenclature</li>
            <li>Conclusion</li>
        </ol>
        <hr />
        <h2 id="introduction">Introduction</h2>
        <p>
            D'une manière similaire aux fonctions, les procédures stockées nous permettent d'exécuter du code au niveau
            de notre SGBD <br>
            À la différence de celles-ci, elles ne retournent par contre pas de données. <br>
            Ceci aura pour conséquence de les favoriser pour des tâches différentes que celles remplies par les
            fonctions. <br>
            Voyons ça ensemble dans ce chapitre.
        </p>
        <h2 id="Nomenclature">Nomenclature</h2>
        <p>
            Compte tenu de la similitude entres les fonctions et les procédures stockées, nous allons étudier un exemple
            un peu plus complet plutôt que de passer chaque points en revue comme pour les fonctions.
        </p>
        <pre class="code-snippet block sql">
CREATE TABLE log_nageur(
	id SERIAL,
	utilisateur text,
	type_action text,
	date_action date,
	description text
);

CREATE OR REPLACE PROCEDURE
enregistre_nageur(nom_nageur varchar(255), prenom_nageur varchar(255))
AS
$$
DECLARE
	exist bool :=  false;
	description_log text := '';
BEGIN

exist := (SELECT EXISTS (
	SELECT FROM information_schema.tables 
	WHERE  table_schema = 'public'
	AND    table_name   = 'nageur'
	));
IF exist = false
THEN
	RAISE EXCEPTION 'table nageur inexistante';
END IF;

exist := (SELECT EXISTS (
	SELECT FROM information_schema.tables 
	WHERE  table_schema = 'public'
	AND    table_name   = 'log_nageur'
	));
IF exist = false
THEN
	RAISE EXCEPTION 'table log_nageur inexistante';
END IF;

INSERT INTO nageur (id, nom, prenom, equipe_id)
VALUES ((SELECT get_next_value('id_nageur')), nom_nageur, prenom_nageur, null);

INSERT INTO log_nageur (utilisateur, type_action, date_action, description)
VALUES ((SELECT CURRENT_USER), 'INSERT', (SELECT CURRENT_DATE), 'Ajout du nageur '||nom_nageur||' '||prenom_nageur );

END;
$$
LANGUAGE PLPGSQL;

-- Appel de la procédure
CALL enregistre_nageur('SMITH', 'JOHN');

SELECT * FROM nageur;
SELECT * FROM log_nageur</pre>
        <p>
            Ici, nous déclarons une procédure qui permet d'enregistrer un nageur dans la table du même nom. <br>
            En plus de faire un insert, elle enregistrera un log informatif dans une table dédiée. <br>
            En utilisant cette procédure stockée, nous nous assurons de bien utiliser la fonction get_next_value, de
            bien encoder un log, de bien reprendre l'utilisateur courant pour ce log et la date courante, que les tables
            nécessaires existent avec une erreur claire cas échéants,... <br>
            On comprend qu'une procédure stockée pourrait réduire la charge de l'utilisateur (un unique appel de
            procédure avec
            2 arguments plutôt que de faire toutes les vérifications et encodage), mais aussi de gérer la "sécurité" de
            notre DB. <br>
            L'utilisateur pouvant avoir accès à une série de procédures stockées au fonctionnement clairement défini
            plutôt qu'un accès direct à des tables
        </p>
        <p>
            Pour ce qui est de la nomenclature, on voit que très peu de choses sont différentes par rapport à une
            fonction. <br>
            L'utilisation du mot-clef "PROCEDURE", la non déclaration d'un type de retour, l'appel à la procédure avec
            le mot-clef "CALL" plutôt que dans un SELECT
        </p>
    </main>

</body>

</html>