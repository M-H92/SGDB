<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Questionnaire de fin de module</title>
    <script
      type="module"
      src="./../../../scripts/sidebar/addSidebar.js"
    ></script>
    <script
      type="module"
      src="./../../../scripts/syntaxHighlighting.js"
    ></script>
    <script type="module" src="./../../../scripts/navbar/addNavbar.js"></script>
    <link rel="stylesheet" href="./../../../ressources/style.css" />
  </head>

  <body>
    <main id="mainElement">
      <h1>Questionnaire de fin de module</h1>
      <ol>
        <li>Introduction</li>
        <li>Diagramme de base de données</li>
        <li>QCM</li>
        <li>Question ouverte</li>
        <!-- <li>Conclusion</li> -->
      </ol>
      <hr />
      <h2 id="introduction">Introduction</h2>
      <p>
        Ci-dessous, un QCM reprenant la plupart des concepts vu jusqu'à présent
        dans ce cours ainsi qu'une question ouverte demandant la création d'un
        diagramme de base de données. <br />
        Essayez de répondre au maximum de question sans vous référencer au cours
      </p>
      <h2 id="diagramme-de-base-de-donnees">Diagramme de base de données</h2>
      <img
        src="../../ressources/img/maisonMedicale.drawio.png"
        alt="database-diagram"
        style="width: 100%"
      />
      <p class="nota-bene info">
        On considère que toute colonne disposent d'une contrainte empêchant les
        valeurs nulles sauf 'praticien.fin_contrat'
      </p>
      <h2 id="qcm">QCM</h2>
      <!-- <p id="question-relation-one-to-many">
      Trouvez toutes les relations correspondant à une relation 1..n (ou 0..n) dans ces propositions :
    </p> -->
      <!-- <ul id="proposition-question-relation-one-to-many">
      <li>1) personne - praticien</li>
      <li>2) praticien - patient</li>
      <li>3) patient - praticien</li>
      <li>4) maison_medicale - conges</li>
    </ul> -->
      <!-- <fieldset id="fieldset-relation-one-to-many">
      <legend>
        Choisir une unique réponses
      </legend>
      <div>
        <input id="answer-1-relation-one-to-many" type="checkbox" name="relation-one-to-many">
        <label for="answer-1-relation-one-to-many">
          Toutes les propositions.
        </label>
      </div>
      <div>
        <input id="answer-2-relation-one-to-many" type="checkbox" name="relation-one-to-many">
        <label for="answer-2-relation-one-to-many">
          Aucune des propositions
        </label>
      </div>
      <div>
        <input id="answer-3-relation-one-to-many" type="checkbox" name="relation-one-to-many">
        <label for="answer-3-relation-one-to-many">
          Les propositions 1, 2 et 3
        </label>
      </div>
      <div>
        <input id="answer-4-relation-one-to-many" type="checkbox" name="relation-one-to-many">
        <label for="answer-4-relation-one-to-many">
          Les propositions 1 et 3
        </label>
      </div>
      <div>
        <input id="answer-5-relation-one-to-many" type="checkbox" name="relation-one-to-many">
        <label for="answer-5-relation-one-to-many">Les propositions 1, 2 et 4</label>
      </div>
    </fieldset> -->
      <!-- <h2>conclusion</h2> -->
      <h2 id="question-ouverte">Question ouverte</h2>
      <p>
        Sur base des information ci-dessous, créer un diagramme de base de
        données qui puisse garder une trace, pour de multiple utilisateurs, des
        sessions de musculation faites et à venir <br />
        On utilisera les informations des muscles impactés principaux et
        secondaires pour générer les sessions suivantes
      </p>
      <p>
        Pour le suivi de son activité sportive, un développeur décide de créer
        une base de données permettant de traiter les informations de ses
        sessions d'entrainement
      </p>
      <p>
        Il organise habituellement de 2 à 3 sessions de musculation par semaine
        comprenant un nombre variable d'exercices
      </p>
      <p>
        Pour optimiser son entrainement, il essaye d'organiser ses sessions de
        telle manière qu'elles se focalise sur un groupe musculaire précis et,
        pour optimiser sa récupération, il essaye d'espacer d'au moins quelques
        jours les sessions se focalisant sur le même groupe musculaire.
      </p>
      <p>
        Ainsi, une semaine type pourrait se composer de 3 sessions : Lundi -
        dos, Mercredi - torse, Vendredi - jambes <br />
        De plus, la semaine suivante ne commencera pas par une session "jambes",
        mais plutôt par une session "dos" (ce groupe musculaire étant le plus
        reposé). <br />
      </p>
      <p>
        En ce qui concerne ces sessions, elles se composent d'une série
        d'exercices s'articulant autours des même muscles "principaux", mais
        ayant un impacte sur une série de muscles "secondaires". <br />
        Par exemple, une séance pourra avoir, entre autres, un exercice de
        développé couché prise large pour lequel le muscule ciblé principal
        serait le grand pectoral avec un effet sur des muscles secondaires qui
        seraient le petit pectoral, le triceps brachial et le deltoïde
        antérieur. <br />
        Dans la même séance, on pourra envisager un exercice de développé Arnold
        ciblant le deltoïde antérieur, supérieur et postérieur ou un exercice
        d'extension à la poulie haute ciblant principalement le triceps
        brachial.
      </p>
      <p>
        Dans une session, chaque exercice se réalises sur x séries de y
        répétitions réalisée avec un poids z. Par exemple, 4 séries de 10
        répétitions de développé couché à 30 kg. (pour cette base de données, on
        ne considère pas les exercices avec variation de répétitions ou de
        poids)
      </p>
    </main>
  </body>
  <script>
    const QCMElement = [
      {
        id: "1",
        difficulte: 1,
        question:
          "Trouvez toutes les relations correspondant à une relation n..n dans ces propositions :",
        codeSnippets: [],
        propositions: [
          "1) praticien - specialite_medicale",
          "2) praticien - maison_medicale",
          "3) patient - dossier_medical",
          "4) praticien - conges",
        ],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "Les propositions 1 et 2.", valeur: true },
          { texte: "Les propositions 2 et 3.", valeur: false },
          { texte: "Les propositions 3 et 4.", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "2",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Trouvez toutes les relations correspondant à une relation 1..1 (ou 0..1) dans ces propositions :",
        propositions: [
          "1) personne - patient",
          "2) patient - praticien",
          "3) dossier_medical - patient",
          "4) praticien - specialite_medicale",
        ],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "Les propositions 1 et 2.", valeur: false },
          { texte: "Les propositions 4 et 5.", valeur: false },
          { texte: "Les propositions 3 et 1.", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "3",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Trouvez toutes les relations correspondant à une relation 1..n (ou 0..n) dans ces propositions :",
        propositions: [
          "1) praticien - conge",
          "2) dossier_medicale - patient",
          "3) patient - personne",
        ],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "Uniquement la 1", valeur: true },
          { texte: "Uniquement la 2", valeur: false },
          { texte: "Uniquement la 3", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "4",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Deux liens relient directement patient et personne : expliquez",
        propositions: [],
        reponses: [
          {
            texte: "Il s'agit d'une erreur, cela semble incohérent",
            valeur: false,
          },
          {
            texte:
              "Un patient peut être une personne, mais l'inverse est aussi vrai",
            valeur: false,
          },
          {
            texte: "Deux relations de FK existent entre patient et personne",
            valeur: true,
          },
          {
            texte:
              "Les deux relations étant nullable, elles s'additionnent en relation non nullable",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "5",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Sur base du schéma, déduisez qui peut insérer un rendez-vous en base de données",
        propositions: [],
        reponses: [
          { texte: "Il est impossible de déduire ça du schéma", valeur: true },
          { texte: "Toute personne", valeur: false },
          { texte: "Tout praticien", valeur: false },
          { texte: "Tout patient", valeur: false },
          {
            texte:
              "Tout praticien lié à une maison médicale et uniquement pour cette maison médicale",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "6",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Sur base du schéma, un praticien peut-il avoir plusieurs spécialités?",
        propositions: [],
        reponses: [
          { texte: "Il est impossible de déduire ça du schéma", valeur: false },
          { texte: "Oui", valeur: true },
          { texte: "Non", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "7",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Laquelle de ces conditions permet de récupérer un praticien n'ayant plus de contrat actif aujourd'hui",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes.", valeur: true },
          { texte: "Toutes les propositions suivantes.", valeur: false },
          { texte: "WHERE praticien.fin_contrat is null", valeur: false },
          { texte: "WHERE praticien.fin_contrat is not null", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "8",
        difficulte: 1,
        codeSnippets: [],
        question: "Laquelle de ces PK est auto incrémentée",
        propositions: [
          "1) personne.identifiant_interne",
          "2) patient.identifiant_interne",
          "3) praticien.identifiant_praticien",
        ],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: true },
          { texte: "La proposition 1", valeur: false },
          { texte: "La proposition 2", valeur: false },
          { texte: "La proposition 3", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "9",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Strictement selon le diagramme, un patient peut-il avoir plusieurs rendez-vous le même jour?",
        propositions: [
          "1) Oui, mais avec un praticien différent",
          "2) Oui, mais avec une heure de début différente",
          "3) Oui, mais avec une heure de fin différente",
          "4) Oui, mais uniquement si le praticien, l'heure de début et l'heure de fin sont toutes strictement différentes",
        ],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "Les propositions 1, 2 et 3", valeur: false },
          { texte: "Les propositions 1 et 2", valeur: false },
          { texte: "Les propositions 2 et 3", valeur: false },
          { texte: "Uniquement la proposition 4", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "10",
        difficulte: 1,
        codeSnippets: [],
        question: "Deux maisons médicales peuvent-elle avoir le même nom?",
        propositions: [],
        reponses: [
          { texte: "Oui", valeur: false },
          { texte: "Non", valeur: true },
          {
            texte:
              "Uniquement si les autres informations permettent de les distinguer",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "11",
        difficulte: 1,
        codeSnippets: [
          `-- A
CREATE DATABASE db_maison_medical;`,
          `-- B
CREATE DATABASE db_maison_medical(EMPTY);`,
          `-- C
CREATE DATABASE db_maison_medical(
	TABLE personne,
	TABLE patient,
	-- code omis par clarté
);`,
          `-- D
CREATE DATABASE db_maison_medical
  WITH TABLES(
	TABLE personne,
	-- code omis par clarté)
);`,
        ],
        question: "Sélectionnez la valide pour créer une base de données",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "A", valeur: true },
          { texte: "B", valeur: false },
          { texte: "C", valeur: false },
          { texte: "D", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "12",
        difficulte: 1,
        codeSnippets: [
          `CREATE TABLE dossier_medical(
  identifiant_patient varchar(32),
  digital boolean,
  access varchar(562)
);`,
        ],
        question:
          "Par rapport à la requête suivante, cocher la ou les bonnes réponses",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions", valeur: false },
          { texte: "La table est créée", valeur: true },
          { texte: "Les types sont correctement définis", valeur: true },
          {
            texte:
              "La primary key est assignée automatiquement car une colonne contient 'identifiant'",
            valeur: false,
          },
          {
            texte:
              "La foreign key est assignée automatiquement car une colonne contient 'identifiant' suivi d'un nom de table",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "13",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Considérant les relations décrites sur le schéma, supprimer la table dossier_medical aura pour effet de",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          {
            texte: "N'aura pas d'impacte sur les données de la table patient",
            valeur: true,
          },
          {
            texte:
              "Supprimer toutes les données de la table patient par 'cascade'",
            valeur: false,
          },
          {
            texte:
              "Supprimer les patient de la table patient par 'cascade', mais uniquement si ils ont un dossier médical",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "14",
        difficulte: 1,
        codeSnippets: [
          `-- A
CREATE TABLE dossier_medical(
  identifiant_patient varchar(32) PRIMARY KEY,
  -- reste des colonnes
); `,
          `-- B
CREATE TABLE dossier_medical(
  identifiant_patient varchar(32),
  -- reste des colonnes
  PRIMARY KEY(identifiant_patient)
);`,
          `-- C
CREATE TABLE dossier_medical(
  identifiant_patient varchar(32),
  -- reste des colonnes
);
ALTER TABLE dossier_medical
ADD PRIMARY KEY(identifiant_patient);`,
        ],
        question:
          "Parmis les requêtes suivantes, lesquelles permettent de créer la table dossier_medical ainsi que sa clé primaire",
        propositions: [],
        reponses: [
          { texte: "Toutes les requêtes", valeur: true },
          { texte: "Aucune des requêtes", valeur: false },
          { texte: "La requête A", valeur: false },
          { texte: "La requête B", valeur: false },
          { texte: "La requête C", valeur: false },
          { texte: "La requête A ainsi que la C", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "15",
        difficulte: 1,
        codeSnippets: [
          `ALTER TABLE dossier_medical SWITCH CONSTRAINT dossier_medical_pkey
FROM dossier_medical.digital TO dossier_medical.identifiant_patient;`,
        ],
        question:
          "Par erreur, la PK (dossier_medical_pkey) de la table dossier_medical a été initialisée sur la colonne 'digital'. On souhaite corriger cette erreur avec la requête suivante. Cochez la bonne réponse.",
        propositions: [],
        reponses: [
          {
            texte:
              "La contrainte de PK est correctement passée de la colonne digital à la colonne identifiant_patient",
            valeur: false,
          },
          {
            texte:
              "La contrainte de PK n'est pas correctement modifiée. La colonne FROM et la colonne TO doivent avoir le même type",
            valeur: false,
          },
          {
            texte:
              "La contrainte de PK n'est pas correctement modifiée. Erreur de syntaxe",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "16",
        difficulte: 1,
        codeSnippets: [
          `ALTER TABLE dossier_medical DROP CONSTRAINT dossier_medical_pkey;
ALTER TABLE dossier_medical ADD PRIMARY KEY(identifiant_patient);`,
        ],
        question:
          "Par erreur, la PK (dossier_medical_pkey) de la table dossier_medical a été initialisée sur la colonne 'digital'. On souhaite corriger cette erreur avec les 2 requêtes suivantes. Cochez la bonne réponse.",
        propositions: [],
        reponses: [
          {
            texte:
              "La contrainte de PK est correctement passée de la colonne digital à la colonne identifiant_patient",
            valeur: true,
          },
          {
            texte:
              "La contrainte de PK n'est pas correctement modifiée. La PRIMARY KEY doit être retirée et réappliquée dans la même requête pour ne pas compremettre l'intégrité des données.",
            valeur: false,
          },
          {
            texte:
              "La contrainte de PK n'est pas correctement modifiée. Erreur de syntaxe",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "17",
        difficulte: 1,
        codeSnippets: [
          `-- A
CREATE TABLE conge(
  identifiant_praticien varchar(32),
  date_debut date,
  -- reste des colonnes
  PRIMARY KEY(identifiant_praticien, date_debut)
);`,
          `-- B
CREATE TABLE conge(
  identifiant_praticien varchar(32) PRIMARY KEY,
  date_debut date PRIMARY KEY,
  -- reste des colonnes
);`,
        ],
        question: "Pour les requêtes suivantes cocher la bonne proposition",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes", valeur: false },
          {
            texte:
              "Les deux requêtes permettent de créer une table 'conge avec une clé primaire sur 'identifiant_praticien' et 'date_debut' ",
            valeur: false,
          },
          {
            texte:
              "La requête A uniquement permet de créer une table 'conge' avec une clé primaire sur 'identifiant_praticien' et 'date_debut' ",
            valeur: true,
          },
          {
            texte:
              "La requête B uniquement permet de créer une table 'conge' avec une clé primaire sur 'identifiant_praticien' et 'date_debut' ",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "18",
        difficulte: 1,
        codeSnippets: [
          `CREATE DATABASE conge(
  identifiant_praticien varchar(32),
  date_debut date,
  date_fin date,
  statut varchar(32),
  PRIMARY KEY(identifiant_praticien, date_debut)
);`,
        ],
        question:
          "Pour créer la table 'conge', cette requête est utilisée. Quelle en sera le résultat?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes", valeur: false },
          { texte: "Erreur de type", valeur: false },
          { texte: "Erreur de contrainte de clé primaire", valeur: false },
          { texte: "Erreur de syntaxe", valeur: true },
          { texte: "Création de la table 'conge'", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "19",
        difficulte: 2,
        codeSnippets: [],
        question:
          "Considérant la table praticien déjà créée et avec la clé primaire renseignée sur le diagramme. Je souhaite ajouter une clé primaire sur la colonne debut_contrat. Sélectionnez la bonne proposition",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes.", valeur: false },
          {
            texte:
              "Impossible d'ajouter la clé : il ne peut y avoir qu'une clé primaire par table",
            valeur: true,
          },
          {
            texte: "Impossible d'ajouter la clé : type incohérent",
            valeur: false,
          },
          {
            texte:
              "Il est possible que cela fonctionne ou pas. Cela dépend des données de la table.",
            valeur: false,
          },
          {
            texte:
              "La clé est ajoutée car le type de la colonne n'est pas nullable. L'intégrité des données est assurée.",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "20",
        difficulte: 2,
        codeSnippets: [],
        question: `Par simplicité, je souhaite modifier la clé primaire de la table 'praticien'. 
      Cochez la ou les propositions valides.
      On considère que je ne fais strictement que ces 3 étapes et dans cet ordre`,
        propositions: [
          `1) Je retire la clé actuelle,`,
          `2) Je rajoute une colonne 'id' de type 'int' `,
          `3) Je crée une contrainte de primary key sur id. `,
        ],
        reponses: [
          { texte: "Aucune des propositions suivantes.", valeur: false },
          { texte: "Erreur lors du retrait de la clé", valeur: false },
          { texte: "Erreur lors de l'ajout de la colonne", valeur: false },
          {
            texte: "Erreur lors de l'ajout de la contrainte de clé primaire",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "21",
        difficulte: 2,
        codeSnippets: [],
        question:
          "Considérant la table praticien déjà créée et sans clé primaire. Je souhaite ajouter une clé primaire sur la colonne debut_contrat. Sélectionnez la ou les bonnes propositions",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes.", valeur: false },
          {
            texte: "Impossible d'ajouter la clé : type incohérent",
            valeur: false,
          },
          {
            texte:
              "Il est possible que cela fonctionne ou pas. Cela dépend des données de la table.",
            valeur: true,
          },
          {
            texte:
              "La clé est ajoutée car le type de la colonne n'est pas nullable. L'intégrité des données est assurée.",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "22",
        difficulte: 1,
        codeSnippets: [
          `CREATE TABLE personne(
  identifiant_interne varchar(32) PRIMARY KEY,
  prenom varchar(32),
  nom varchar(32),
  telephone varchar(32)
);`,
        ],
        question:
          "Considérant que la table 'personne' n'est pas encore créée, cochez la proposition valide pour la requête suivante.",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes.", valeur: true },
          { texte: "Erreur de syntaxe", valeur: false },
          { texte: "Erreur de type", valeur: false },
          {
            texte: "Erreur dans la définition de la contrainte de clé primaire",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "23",
        difficulte: 1,
        codeSnippets: [
          `-- A
ALTER TABLE praticien ALTER COLUMN debut_contrat SET NOT NULL;`,
          `-- B
ALTER TABLE praticien ALTER COLUMN fin_contrat SET NULL;`,
        ],
        question:
          "Considérant la table praticien décrite dans le diagramme, sélectionnez laquelle de ces requêtes est correcte",
        propositions: [],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "La requête A", valeur: true },
          { texte: "La requête B", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "24",
        difficulte: 1,
        codeSnippets: [
          `ALTER TABLE praticien 
  ADD CONSTRAINT fk_praticien_personne FOREIGN KEY (identifiant_praticien) 
  REFERENCES personne (identifiant_interne);`,
        ],
        question:
          "Après avoir défini cette contrainte de clé étrangère, quel aura l'impacte de la suppression d'un 'praticien'?",
        propositions: [],
        reponses: [
          {
            texte:
              "Erreur : impossible de supprimer le praticien, il faut passer par la personne liée",
            valeur: false,
          },
          { texte: "Un praticien est supprimé", valeur: true },
          {
            texte: "Un praticien et la personne liée sont supprimés",
            valeur: false,
          },
          { texte: "Une personne est supprimée", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "25",
        difficulte: 1,
        codeSnippets: [
          `ALTER TABLE praticien 
  ADD CONSTRAINT fk_praticien_personne FOREIGN KEY (identifiant_praticien) 
  REFERENCES personne (identifiant_interne);`,
        ],
        question:
          "Cochez toutes les propositions 'possibles' à la suppression d'une 'personne' après avoir défini cette contrainte de clé étrangère",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions suivantes", valeur: true },
          {
            texte: "Erreur, impossible de supprimer la personne",
            valeur: true,
          },
          { texte: "Suppression de la personne", valeur: true },
          { texte: "Suppression d'un praticien", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "26",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Lors de la création d'une clé étrangère, quelle comportement 'ON DELETE' est appliqué par défaut",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: true },
          { texte: "CASCADE", valeur: false },
          { texte: "RESTRICT", valeur: false },
          { texte: "SET DEFAULT", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "27",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Lors de la création d'une clé étrangère, quelle comportement 'ON UPDATE' est appliqué par défaut",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "SET NULL", valeur: false },
          { texte: "THROW", valeur: false },
          { texte: "NO ACTION", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "28",
        difficulte: 1,
        codeSnippets: [
          `ALTER TABLE praticien 
  ADD CONSTRAINT fk_praticien_personne FOREIGN KEY (identifiant_praticien) 
  REFERENCES personne (identifiant_interne);
ALTER TABLE patient 
  ADD CONSTRAINT fk_patient_personne FOREIGN KEY (identifiant_interne) 
  REFERENCES personne (identifiant_interne);`,
        ],
        question:
          "Cochez la ou les informations correctes après application du code suivant",
        propositions: [],
        reponses: [
          {
            texte:
              "Une personne peut exister sans être un praticien, mais elle doit être un patient",
            valeur: false,
          },
          {
            texte:
              "Une personne peut exister sans être un patient, mais elle doit alors être un praticien",
            valeur: false,
          },
          {
            texte:
              "Une personne peut exister sans être ni un praticien, ni un patient",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "29",
        difficulte: 1,
        codeSnippets: [
          `-- A
ALTER TABLE patient ADD COLUMN inscrit_maison_medical boolean;`,
          `-- B
UPDATE TABLE patient ADD COLUMN inscrit_maison_medical boolean;`,
          `-- C
MODIFY TABLE patient ADD COLUMN inscrit_maison_medical boolean;`,
        ],
        question:
          "Considérant que la table 'patient' a été créée sans la colonne 'inscrit_maison_medicale', quelle requête permet d'ajouter cette colonne?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "La requête A", valeur: false },
          { texte: "La requête B", valeur: false },
          { texte: "La requête C", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "30",
        difficulte: 1,
        codeSnippets: [],
        question:
          "Considérant que la table 'patient' a été créée sans la colonne 'inscrit_maison_medicale', on tente de l'ajouter en modifiant par après. Cochez là ou les bonnes réponses",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          {
            texte:
              "Impossible d'ajouter une colonne dans une table existante. Il faut la supprimer et la créer avec toutes les colonnes",
            valeur: false,
          },
          {
            texte:
              "Il est possible de rajouter cette nouvelle colonne, mais, pour chaque ligne de la table, une valeur [null] sera attribuée à la nouvelle colonne",
            valeur: true,
          },
          {
            texte:
              "Il est possible de rajouter cette nouvelle colonne, mais elle n'entre en compte que pour les lignes insérées par après",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "31",
        difficulte: 2,
        codeSnippets: [
          `-- A
INSERT INTO personne
VALUES('JDOE', 'Jon', 'Doe', '+3247777777');`,
          `-- B
INSERT INTO personne (identifiant_interne, prenom, nom)
VALUES('JLEN', 'John', 'Lennon');`,
          `-- C
INSERT INTO personne (identifiant_interne, prenom, nom, telephone)
VALUES('JARB', 'Jon', 'Arbuckle', '+35247777777');`,
          `-- D
INSERT INTO personne (telephone, prenom, nom, identifiant_interne)
VALUES('+3347777777', 'Jon', 'Bon Jovi', 'JBON');`,
        ],
        question: "Laquelle de ces requête permet de créer une personne",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions ci-dessous.", valeur: false },
          { texte: "Toutes les requêtes.", valeur: false },
          { texte: "Aucune des requêtes.", valeur: false },
          { texte: "Les requêtes A, B et C.", valeur: false },
          { texte: "Les requêtes B, C et D.", valeur: false },
          { texte: "Les requêtes A, C, et D.", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "32",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO personne (identifiant_interne, prenom, nom)
VALUES('BMAR', 'Bob', 'Marley'),
('BLEN', 'Bob', 'Lennon'),
('BAFF', 'Bob', 'Affet');`,
        ],
        question: "Quel sera le résultat de cette requête?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "Erreur, aucune personne n'est enregistrée", valeur: false },
          {
            texte: "Erreur, seule la première personne est enregistrée",
            valeur: false,
          },
          { texte: "Les trois personnes enregistrées", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "33",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO personne 
VALUES('SLJA', 'Sammuel L.', 'Jackson', '0032477777777');`,
          `INSERT INTO personne (identifiant_interne, prenom, nom, telephone)
VALUES('SLJA', 'Sammuel L.', 'Jackson', '0032477777777');`,
        ],
        question: "Prise individuellement, ces deux requêtes",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions ci-dessous", valeur: false },
          { texte: "Les deux propositions ci-dessous", valeur: false },
          { texte: "Résultent en une erreur", valeur: false },
          { texte: "Sont fonctionnellement identique", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "34",
        difficulte: 2,
        codeSnippets: [
          `INSERT INTO patient 
(SELECT identifiant_interne FROM personne)`,
        ],
        question: "Quel aura pour effet cette requête?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: true },
          {
            texte: "Toutes les propositions suivantes spécifiant une erreur.",
            valeur: false,
          },
          { texte: "Erreur, clause WHERE manquante", valeur: false },
          {
            texte: "Erreur, mot-clé INSERT et SELECT incompatible",
            valeur: false,
          },
          {
            texte:
              "Réussite, plusieurs patients sont insérés en base de données",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "35",
        difficulte: 1,
        codeSnippets: [
          `-- A
SELECT identifiant_interne FROM personne
WHERE identifiant_interne NOT IN
(SELECT pr.identifiant_praticien FROM praticien as pr
LEFT JOIN personne as pe
	on pr.identifiant_praticien = pe.identifiant_interne)`,
          `-- B
SELECT identifiant_interne FROM personne as pe
LEFT JOIN praticien as pr
ON pr.identifiant_praticien = pe.identifiant_interne
WHERE pr.identifiant_praticien IS NULL`,
        ],
        question:
          "Pour ces deux requêtes, sélectionnez les bonnes propositions",
        propositions: [],
        reponses: [
          {
            texte: "Elles résultent toutes les deux en une erreur",
            valeur: false,
          },
          { texte: "La requête A échoue et la B réussi", valeur: false },
          { texte: "La requête B échoue et la A réussi", valeur: false },
          {
            texte:
              "Les deux requêtes réussissent et produisent le même résultat",
            valeur: true,
          },
          {
            texte:
              "Les deux requêtes réussissent et produisent un résultat différent",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "36",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO patient (identifiant_interne, nom_generaliste, telephone_generaliste, personne_contact, inscrit_maison_medical)
VALUES ('SLEG', 'Dupont Luc', '0035245784575', 'SLEG', false);`,
        ],
        question:
          "Considérant qu'un enregistrement existe dans la table 'personne' avec l'identifiant_interne 'SLEG', quel sera le résultat de cette requête",
        propositions: [],
        reponses: [
          { texte: "Aucune des valeurs ci-dessous", valeur: false },
          {
            texte:
              "Erreur, la valeur SLEG est déjà utilisée et une PRIMARY KEY ne peut être dupliquée",
            valeur: false,
          },
          {
            texte:
              "Erreur, la valeur SLEG ne peut être utilisée, dans la table patient, pour deux FOREIGN KEY différente",
            valeur: false,
          },
          {
            texte: "Réussite, un patient est enregistré en base de données",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "37",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO specialite_medicale(nom, description)
VALUES ('Pédiatrie', '');
INSERT INTO praticien_specialite_medicale (identifiant_praticien, nom_specialite_medicale)
VALUES ('JDOE', 'Pédiatrie');`,
        ],
        question:
          "Considérant qu'un praticien est enregistré avec l'identifiant JDOE, on tente d'exécuter ces deux requêtes. Quel sera le résultat?",
        propositions: [],
        reponses: [
          { texte: "Erreur, les deux requêtes échouent", valeur: false },
          {
            texte: "Réussite partielle, une des requête échoue",
            valeur: false,
          },
          { texte: "Réussite, les deux requêtes fonctionnent", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "38",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO praticien_specialite_medicale (identifiant_praticien, nom_specialite_medicale)
VALUES ('JDOE', 'Généraliste');
INSERT INTO specialite_medicale(nom, description)
VALUES ('Généraliste', '');`,
        ],
        question:
          "Considérant qu'un praticien est enregistré avec l'identifiant JDOE, on tente d'exécuter ces deux requêtes. Quel sera le résultat?",
        propositions: [],
        reponses: [
          { texte: "Erreur, les deux requêtes échouent", valeur: false },
          {
            texte: "Réussite partielle, une des requête échoue",
            valeur: false,
          },
          { texte: "Réussite, les deux requêtes fonctionnent", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "39",
        difficulte: 1,
        codeSnippets: [
          `INSERT INTO specialite_medicale(nom, description)
VALUES ('', '');`,
        ],
        question:
          "Considérant une table 'specialite_medicale' sans données, quel sera le résultat de cette requête?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions ci-dessous", valeur: false },
          {
            texte: "Erreur, une valeur est requise pour la PRIMARY KEY",
            valeur: false,
          },
          { texte: "Erreur, syntaxe incorrecte", valeur: false },
          { texte: "Réussite", valeur: true },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "40",
        questionnaire: ["A", "B"],
        difficulte: 1,
        codeSnippets: [
          `-- A
SELECT * FROM specialite_medicale`,
          `-- B
SELECT nom, description FROM specialite_medicale`,
        ],
        question:
          "Sans considération pour l'ordre des colonnes ou des rangées, sélectionnez la bonne affirmation pour ces deux requêtes",
        propositions: [],
        reponses: [
          {
            texte: "La requête A récupère plus de colonnes que la B",
            valeur: false,
          },
          {
            texte: "La requête B récupère plus de colonnes que la A",
            valeur: false,
          },
          {
            texte: "Les deux requêtes récupère les mêmes informations",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "41",
        questionnaire: ["A", "B"],
        difficulte: 1,
        codeSnippets: [
          `-- A
WHERE description = ''`,
          `-- B
WHERE description LIKE '%'`,
          `--C
WHERE description LIKE '_'`,
        ],
        question:
          "Laquelle de ces propositions permet de récupérer toutes les specialités médicales lors d'un `SELECT * FROM specialite_medicale`",
        propositions: [],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "La proposition A", valeur: false },
          { texte: "La proposition B", valeur: false },
          { texte: "La proposition C", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "42",
        difficulte: 1,
        codeSnippets: [
          `SELECT * FROM specialite_medicale as sm
[---] JOIN praticien_specialite_medicale AS psm
ON psm.nom_specialite_medicale = sm.nom;`,
        ],
        question:
          "Je ne souhaite récupérer que les spécialités médicales attribuées à au moins un praticien. Quelle mot clé utiliser à la place des [---]",
        propositions: [],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "LEFT", valeur: false },
          { texte: "INNER", valeur: true },
          { texte: "RIGHT", valeur: false },
          { texte: "CROSS", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "43",
        difficulte: 2,
        codeSnippets: [
          `-- A
SELECT identifiant_interne FROM personne AS p
JOIN patient AS pa 
ON pa.identifiant_interne = p.identifiant_interne;`,
          `-- B
SELECT identifiant_interne FROM personne AS p
JOIN praticien AS pr 
ON pr.identifiant_praticien = p.identifiant_interne;`,
        ],
        question: "Ces requêtes sont utilisées. Cochez la bonne réponse",
        propositions: [],
        reponses: [
          { texte: "La requête A et B fonctionnent", valeur: false },
          { texte: "La requête A fonctionne. La B échoue.", valeur: false },
          {
            texte: "La requête A échoue. La requête B fonctionne",
            valeur: true,
          },
          { texte: "La requête A et B échouent", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "44",
        difficulte: 2,
        codeSnippets: [
          `-- A
SELECT * FROM specialite_medicale as sm
INNER JOIN praticien_specialite_medicale AS psm
ON psm.nom_specialite_medicale = sm.nom;`,
          `-- B
SELECT * FROM specialite_medicale as sm
JOIN praticien_specialite_medicale AS psm
ON psm.nom_specialite_medicale = sm.nom;`,
        ],
        question: "Les deux requêtes sont utilisées. Cochez la bonne réponse",
        propositions: [],
        reponses: [
          {
            texte: "La requête A retourne plus de rangées que la B",
            valeur: false,
          },
          {
            texte: "La requête B retourne plus de rangées que la A",
            valeur: false,
          },
          {
            texte: "Les deux requêtes retournent le même nombre de rangées",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "45",
        difficulte: 3,
        codeSnippets: [
          `-- A
SELECT identifiant_interne FROM personne AS p
LEFT JOIN praticien AS pr 
ON pr.identifiant_praticien = p.identifiant_interne;`,
          `-- B
SELECT identifiant_interne FROM praticien AS pr
LEFT JOIN personne AS p 
ON pr.identifiant_praticien = p.identifiant_interne;`,
        ],
        question:
          "Considérant que des données existent pour des praticiens et des patients, cochez la bonne réponse pour comparer ces deux requêtes",
        propositions: [],
        reponses: [
          {
            texte: "La requête A retourne plus de rangées que la requête B",
            valeur: true,
          },
          {
            texte: "La requête B retourne plus de rangées que la requête A",
            valeur: false,
          },
          {
            texte: "Les deux requêtes retournent le même nombre de rangées",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "46",
        difficulte: 3,
        codeSnippets: [
          `-- A
SELECT identifiant_interne FROM personne AS p
RIGHT JOIN praticien AS pr 
ON pr.identifiant_praticien = p.identifiant_interne;`,
          `-- B
SELECT identifiant_interne FROM personne AS p
LEFT JOIN praticien AS pr 
ON pr.identifiant_praticien = p.identifiant_interne;`,
        ],
        question:
          "Considérant que des données existent pour des praticiens et des patients, cochez la bonne réponse pour comparer ces deux requêtes",
        propositions: [],
        reponses: [
          {
            texte: "La requête A retourne plus de rangées que la requête B",
            valeur: false,
          },
          {
            texte: "La requête B retourne plus de rangées que la requête A",
            valeur: true,
          },
          {
            texte: "Les deux requêtes retournent le même nombre de rangées",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "47",
        difficulte: 1,
        codeSnippets: [
          `-- A
SELECT * FROM conge
WHERE date_debut > CURRENT_DATE AND date_fin < CURRENT_DATE;`,
          `-- B
SELECT * FROM conge
WHERE date_debut > CURRENT_DATE OR date_fin < CURRENT_DATE;`,
          `-- C
SELECT * FROM conge
WHERE date_debut <= CURRENT_DATE AND date_fin > CURRENT_DATE;`,
          `-- D
SELECT * FROM conge
WHERE date_debut <= CURRENT_DATE OR date_fin > CURRENT_DATE;`,
        ],
        question:
          "Laquelle de ces requêtes permet de récupérer les identifiant des praticiens en congé aujourd'hui",
        propositions: [],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "La requête A", valeur: false },
          { texte: "La requête B", valeur: false },
          { texte: "La requête C", valeur: true },
          { texte: "La requête D", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "48",
        difficulte: 2,
        codeSnippets: [
          `-- A
SELECT * FROM conge
WHERE date_debut > CURRENT_DATE AND date_fin < CURRENT_DATE;`,
          `-- B
SELECT * FROM conge
WHERE date_debut > CURRENT_DATE OR date_fin < CURRENT_DATE;`,
          `-- C
SELECT * FROM conge
WHERE date_debut <= CURRENT_DATE AND date_fin > CURRENT_DATE;`,
          `-- D
SELECT * FROM conge
WHERE date_debut <= CURRENT_DATE OR date_fin > CURRENT_DATE;`,
        ],
        question:
          "Laquelle de ces requêtes permet de récupérer les identifiant des praticiens en congé aujourd'hui et n'ayant pris qu'un seul jour de congé? (ils ne sont donc en congé ni hier ni demain)",
        propositions: [],
        reponses: [
          { texte: "Toutes les propositions.", valeur: false },
          { texte: "Aucune des propositions.", valeur: true },
          { texte: "La requête A", valeur: false },
          { texte: "La requête B", valeur: false },
          { texte: "La requête C", valeur: false },
          { texte: "La requête D", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "49",
        difficulte: 1,
        codeSnippets: [
          `CREATE TABLE maison_medicale(
  nom varchar(64) PRIMARY KEY,
  adresse varchar(256),
  telephone varchar(32),
  mail varchar(256),
  site_web varchar(256)
);`,
        ],
        question:
          "Je souhaite créer la table 'maison_medicale' et j'utilise cette requête. Cochez la bonne réponse",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          { texte: "La table est créée", valeur: true },
          {
            texte: "Erreur pour la déclaration de la clé primaire",
            valeur: false,
          },
          { texte: "Erreur pour la déclaration des types", valeur: false },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "50",
        difficulte: 3,
        codeSnippets: [
          `-- A
SELECT pr.identifiant_praticien FROM praticien AS pr
JOIN praticien_maison_medicale AS p_mm
ON p_mm.identifiant_praticien = pr.identifiant_praticien
WHERE p_mm.nom_maison_medicale = 'Arlon';`,
          `-- B
SELECT p_mm.identifiant_praticien FROM maison_medicale AS mm
JOIN praticien_maison_medicale AS p_mm
ON p_mm.nom_maison_medicale = mm.nom
WHERE mm.nom = 'Arlon';`,
          `-- C
SELECT identifiant_praticien FROM praticien_maison_medicale
WHERE nom_maison_medicale = 'Arlon'`,
        ],
        question:
          "Je souhaite récupérer l'identifiant des praticiens de la maison médicale d'arlon. Considérant ces trois requêtes, sélectionnez la bonne réponse",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          {
            texte: "La requête A, B et C retournent les valeurs voulues",
            valeur: true,
          },
          {
            texte: "La requête A et B retournent les valeurs voulues",
            valeur: false,
          },
          {
            texte: "La requête A et C retournent les valeurs voulues",
            valeur: false,
          },
          {
            texte: "La requête B et C retournent les valeurs voulues",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "51",
        difficulte: 1,
        codeSnippets: [
          `UPDATE conge SET statut = 'Accepté'
WHERE date_debut > CURRENT_DATE;`,
        ],
        question:
          "Je souhaite accepter tout les congés posés à venir. Est-ce que cette requête répond à mon besoin?",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          {
            texte: "Oui, tout les congés futurs sont maintenant acceptés",
            valeur: true,
          },
          {
            texte:
              "Erreur, statut ne peut pas prendre la valeur 'Accepté'. Uniquement true ou false",
            valeur: true,
          },
          {
            texte: "Erreur, impossible de combiner les clauses UPDATE et WHERE",
            valeur: true,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      {
        id: "52",
        difficulte: 1,
        codeSnippets: [`DELETE FROM conge WHERE statut = 'Refusé'`],
        question:
          "Je souhaite supprimer les congés refusés. Pour cela, j'utilise cette requête. Cochez la bonne réponse",
        propositions: [],
        reponses: [
          { texte: "Aucune des propositions.", valeur: false },
          {
            texte: "Les congés dont le statut est 'Refusé' sont supprimés",
            valeur: true,
          },
          {
            texte: "Erreur, impossible de combiner les clauses DELETE et WHERE",
            valeur: false,
          },
        ],
        nbrReponseCorrecte: () => {
          return this.reponses.filter((p) => p.valeur === true).length;
        },
      },
      // {
      //   id: "53",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "54",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "55",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "56",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "57",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "58",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "59",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "60",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "61",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "62",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "63",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "64",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
      // {
      //   id: "65",
      //   difficulte: 1,
      //   codeSnippets: [],
      //   question: "",
      //   propositions: [
      //     "1) ",
      //     "2) ",
      //     "3) ",
      //     "4) ",
      //     "5) ",
      //   ],
      //   reponses: [
      //     { texte: "Toutes les propositions.", valeur: false },
      //     { texte: "Aucune des propositions.", valeur: false },
      //     { texte: "", valeur: false },
      //   ],
      //   nbrReponseCorrecte: () => {
      //     return this.reponses.filter(p => p.valeur === true).length;
      //   }
      // },
    ];

    const QCMElementSet = new Set(QCMElement.map((e) => e.id));
    if (QCMElementSet.size != QCMElement.length)
      console.error("duplicata dans les id du qcm");

    function populateBody() {
      const main = document.getElementById("qcm");
      QCMElement.sort((a, b) => (+a > +b ? 1 : -1)).forEach((e) => {
        const hr = document.createElement("hr");
        hr.style.width = "75%";
        hr.style.marginTop = "16px";
        hr.style.marginBottom = "24px";
        main.after(hr);
        const element = document.createElement("p");
        element.id = `question-${e.id}`;
        element.textContent = `${e.id}) ${e.question}`;
        main.after(element);

        const ul = document.createElement("ul");
        ul.id = `proposition-${e.id}`;

        const propositions = e.propositions.forEach((p) => {
          let prop = document.createElement("li");
          prop.textContent = p;
          ul.appendChild(prop);
        });
        element.after(ul);

        const codeWrapper = document.createElement("div");
        codeWrapper.id = `code-snippets-${e.id}`;
        codeWrapper.classList.add("container");

        e.codeSnippets.forEach((c) => {
          let pre = document.createElement("pre");
          pre.textContent = c;
          pre.classList.add("code-snippet");
          pre.classList.add("block");
          codeWrapper.appendChild(pre);
        });
        element.after(codeWrapper);

        const fieldset = document.createElement("fieldset");
        fieldset.id = `fieldset-${e.id}`;
        const legend = document.createElement("legend");
        if (e.nbrReponseCorrecte === 1)
          legend.textContent = "Choisir une unique réponse";
        else legend.textContent = "Choisir une ou plusieurs réponse(s)";

        let i = 1;
        e.reponses.forEach((r) => {
          const div = document.createElement("div");
          const reponse = document.createElement("input");
          reponse.type = "checkbox";
          reponse.id = `answer-${i}-${e.id}`;
          reponse.name = e.id;
          const label = document.createElement("label");
          label.textContent = `${i}) ${r.texte}`;
          label.htmlFor = reponse.id;
          div.appendChild(reponse);
          div.appendChild(label);
          fieldset.appendChild(div);
          i++;
        });
        ul.after(fieldset);
      });
    }
    populateBody();
  </script>
</html>
